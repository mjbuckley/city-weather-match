TO DO NOW (IMPORTANT)

-Right now the process for adding new weather options is long and error prone. I big part of this is how I pass around props, but there are other issues too. See if I can simplify this.
-I've used parseInt in many places to coerce string to number. However, this results in an int value. Not sure this is always what I want. Check my useage of this and fix (with Number?) if needed. Also check my usage in the files that build weather.json. In some places it might be ok because I'm limiting values to ints in the range slider, but make sure everything makes sense.
-Figure out css in react. I added a styling for a the match class in stationlink.css but for some reason that affected things in citystationlink. I have no idea why, so I clearly need to go over this.
-LOOK INTO SYNTAX HIGHLIGHTING FOR REACT, ESP FOR JSX
-IMPORTANT: I think I'm add my li keys in the wrong place in some areas. Double check.
-Need to figure out exactly how I want to use isClicked. Specifically, I have components (location, citylocations, and metroarea) that should work differently depending on isClicked's status. Also, I've gone through to try and make sure that no component currently is assuming one status or another without that assumption being hard coded in and both possibilities dealt with, but go through again and make sure this is the case.
-Add in weather graphs. Decide on plotly or somthing else.
-Add in more weather info.
-Decide on best way to handle inputs (sliders or something else?).

-Get at least a basic understanding of some of the things going on under the hood in create-react-app (like webpack).
-I really need to figure out how I'm ultimately going to deploy this. Things like 404s and browser/hashHistory will really depend on deployment choices and can't be decided in isolation.
-I've tried to use decodeURIComponent() everywhere (even when I shouldn't be needed) but go through and make sure I haven't missed any places.
-Are there any security issue I need to be aware of when grabbing from url params/query params? I'm thinking primarily of sanitization to avoid JS somehow being passed in and executed. Not having a server/db makes me safe, but I guess the concern would be malicious JS put into a link that was then shared. I'd be fine, but not the people who clicked on the link. Look into this.
-The li section in many components where I list a city name is probably very similar or the same. See if I can extract this into a shared component.
-Figure out how to handle search page vs. search done from home page. Similarly, how to handle query params and the home page (and what about on search? I think yes on search?). There are thoughts both ways. This is what I was thinking a while ago:
  I'm not going to add query params to the home/search link. If someone bookmarked the home site it would almost certainly be to remember/share the page in general, not to remember the particular search params on the range sliders at the time. In fact, having the slider be anything but the default would probably be confusing. Plus, if they are navigating to search/home page from elsewhere on the site, their current state will already be reflected in the sliders. MY ONLY QUESTION is if this could have any effect on the ability to navigate backwards (url recreating state seems to help with back navigation). I Think its ok, but watch for this.
-Keep in mind that there could be times when there are valid query params but no matches. Make sure there's nowhere that assume valid query params means that there are matches.


TO DO IN FUTURE (BUT NOT IMMEDIATELY CRITICAL)

-Don't forget checking in different browsers/devices/OSes. Basic functionality seems fine in Safari and Firefox, but be sure to check everywhere. Also, I do see some minor style differences I should see if I can fix.
-The url param error/mismatch checking all works as it should, but some of it can be pretty ugly. Take a look about cleaning it up/extracting stuff.
-I made a really basic simulation of a 404 page (works the same way but is actually a 200 response). It seems to be working, but make it a bit better and test edge case more.
-Washington DC looks like it has been mapped to Maryland. Manually correct? Others like this?
-Why does some components seem to be rendering twice on load? For example, on some components if I console.log different variables they will be logged twice. Figure out what's happening.
-Right now my weatheroptions.js file is hand made. See if I can automate that and make it a 5th file to be created by jsoncreate.js.
-Ways to make weather.json smaller: I think there are some things in there I'm not using. Take a look (maybe sharedarea or area?). Also, I could do something where I group types of data together in an array like snow: [1, 3, 4] where each element is a type of snow data. It's a bit less friendly, but could free up some space. Finally, probably go through and remove stations not in the 50 states (and what about water stations if they exist).
-I think I've made sure weather values are treated as integers and not strings, but go through an make sure that I've done everything properly. Also be explicit about which functions are expecting ints and where the string int conversion needs to happen in the future.
-I have been following this convention, but I should note it somewhere: Where there are multiple possible stations that match for a city, I will always return the first one in the array that matches. When there are no matches, I will always link to the first in the array. And when there are some that match and some that don't match, I will alway return the first that is a match. This should ensure consistent results when navigating the site (avoids something like linking to one LA station from results page and a different one when you click on LA from the metro areas page).
-Two pages with the same url but different query params are treated as different by the browser purposes of have visited links. This mostly makes sense, but I can imagine ways it could be confusing. I guess the question is should I have clicked links be a different color or not? More web page-like or app-like?
-Is there any practical/performance difference between defining a constant inside vs. outside a function?
-In weather.json my "mTmnAv" and "mTmxAv" have the last element as a number and all others as strings. Why? Also, second m should probably be capitalized (mTMxAvg).
-Is normalize.css still a thing? Should I use it? Is it already included somehow? Is there a better alternative or something that can be done using post.css?



MAYBE TO DO IN FUTURE (WOULD BE GOOD BUT NOT CRITICAL)

-Should the li in CitiesList be ol instead of ul?
-componentWillMount and componentWillReceiveProps are exactly the same except for one using this.props and the other nextProps. I'm fine with this for now, but maybe extract into a shared function in the future.
-In componentWillMount and componentWillReceiveProps I have two functions that take props/nextProps. One takes everything, the other takes .location.query. Both only use .location.query. I'm passing in what the functions expect, and everything works, but should probably just have everything set up to use .location.query because that's what's being used and it's much more clear.
-There are several places where I do something like passing this.props when really I don't need everything. I do this because it's cleaner/simpler, but I should probably only pass what I need. Also, could the spread operator be used here?
-On search.js I can probably make the separate range input even handlers into one function.
-Be sure to note something about how different stations have different numbers of years on record, and more generally about putting the data into context (Useful if you aren't overly exact about things).
-I added a link to the home page using <Link to="/">. This works fine, but should I use Navlink or maybe a named home link?
-Should my weatherOptions const be capitalized? What about all consts?
-A lot of times I'm pass a props object around. I then reassign the properties in the object to variables. I think this might be a place to use the new object destructor function to make things easier to follow, but not sure. Look into it.
-Ideally I should change how I handle partial valid url query params. Right now, I fill in the gaps with default values and appropriately update state as needed, but I leave the incomplete url unchanged. The problem here is that if React ever needs to run componentWillReceiveProps, then the whole process of needing to fill in the gaps and compare to state will need to happen again. Everything will ultimately still work, but it would be nice if this could be avoided. So, perhaps find a way to alter url when I fill in gaps?
-Do I need a json loader? What I'm doing (require) seems to be working fine, but I've seen references to needing one with webpack (version 1, not version 2, but I think create-react-app uses v.1 right now). Lots of stuff is hidden with create-react-app, so maybe some sort of loader is already included? Also, I've seen suggestions that it's better to load with webpack. Not 100% sure why, but worth looking in to. Keep all this in mind if anything weird starts happening/figure out why webpack might be a better solution.



NOTES

-I went to Google's Material Design color picking site and picked a set of colors. I didn't spend too much time on it, but just did something to get me started. That said, it looks decent, and I think the site might be useful in the future. I can get my colors and examples at: https://material.io/color/#!/?view.left=0&view.right=0&primary.color=039BE5&secondary.color=9e9e9e
-I was running in to an odd bug on chrome where some sliders where rendering in a different height than others. I was able to fix this by changing the track height from 2.8 to 3. Maybe the pixels were the problem? Keep in mind if something weird like this happens again.
-Might look in to Lodash function memoization. Lodash looks interesting in general, but the memoization could be a better way to handle the "cacheing" I do with state.
-Get better sense of using the spread operator.
-Not using this, but saving as a reminder. It is a way to find out if query params are the same as the default state values. I thought hard on how to make this, and I'm happy with the result (and could make even more concise w/ann anonymous fat arrow function):
  Object.keys(weatherOptions).every(function(element) {
    return nextProps.location.query[element] === weatherConts[element][2];
  });



ERROR CHECKING:
-Three types of issues to check for: 1) invalid city/station/state/metro names, 2) valid names that don't match, and (ex: Los Angeles, Ohio), and 3) invalid query params (ex: days below 32 = kdsjflks). Below are my notes of what I need to check where.

APP:
-Make sure all possible query param possibilities can be handled and state updated as needed. (done).

HOME:
-NO url params to worry about. I'm also not using query params for home, so nothing to check (although it would work fine with query params). The way I have it set up isActive will always be false, although it wouldn't hurt anything if it were true. So, nothing to do.

SEARCH:
-No url params and works regardless of query params, so nothing to do.

RESULTS:
-Need to check the status of isActive. If false, then results make no sense and need to give an error message. Otherwise nothing to do. (done)

METROAREA:
-Verify that metro area url param is valid. (done: see if metro area param is in metroMap. If not, it's invalid. Give error message).
-TO DO: isActive (currently doesn't do anything different when active/inactive. No errors either way, but should make it responsive to state).

CITYLOCATIONS:
-Handle invalid city/state url params. (done: checks stationsObj for every station matching both params. Will return an empty array if either are invalid (or if valid but mismatched). So, just check for empty array and give error message).
-TO DO: isActive (currently doesn't do anything different when active/inactive. No errors either way, but should make it responsive to state).

LOCATION:
-Make sure station id is valid. (done: check for stationsObj[station] and return error message if not in stationsObj).
-Make sure that city and state params in url match station id. (done: find city and state for stationsObj[station] and see if the match the url city and state params. Return error message if they don't match.)
-TO DO: isActive (currently doesn't do anything different when active/inactive. No errors either way, but should make it responsive to state).

OTHER:
-Make sure that urls not matching one of the routes returns a "404" page. (done: notfound.js).



PLACES WHERE INFO NEEDS TO BE UPDATED WHEN NEW WEATHER OPTIONS ARE ADDED

1) Add the date in jsoncreate.js in weather data project
2) Manually alter the min max default matches creation function in weather data project.
3) Run jsoncreate.js and copy over the 4 altered files.
4) Add default value to default state in App.
5) Add to props to pass children in App.
6) Update weatheroptions.js
7) Update defaults const in paramstovalues.js
8) Update findmatches.js
9) Update props passed to search in home.js
10) On search add to state, create change value function and bind it to this, add to fetch data function, and add range slider.
11) Add to props passed to citieslist in results.js.
12) Add to buildparams.js (5/13: no longer using this file)
13) Add to location.js in weather info and in the props passed to sharedarealist.js.
14) Add to props passed to citylist on citieslist.js.
15) Update data examples for future reference.




WEATHER OPTIONS

Cold Days
1) Average low temp for the coldest month of the year is greater than X. (lMTMnGe)
2) Number of days the temp drops below freezing is less than X. (d32Le)
3) Number of days the temp drops below freezing is greater than X. (d32Ge)

Warm Days
4) Average high temp for the hottest month of the year is less than X. (HMTMxLe)
5) Number of days the temp gets above 80 is less than X. (d80Le)
6) Number of days the temp gets above 80 is greater than X. (d80Ge)
7) Number of days the temp gets above 60 is greater than X. (d60Ge)
8) Number of days the temp gets above 60 is less than X. (d60Le)

Precip
9) Number of days with an inch or more if snowfall is greater than X. (dSn1Ge)
10) Number of days with an inch or more if snowfall is less than X. (dSn1Le)
11) Number of days with an inch or more of snow cover is greater than X. (dSnC1Ge)
12) Number of days with an inch or more of snow cover is less than X. (dSnC1Le)
13) Number of rainy days (.5 inch of precip or more) is less than X. (dPr5TiLe)
14) Number of rainy days (.5 inch of precip or more) is greater than X. (dPr5TiGe)


5/13/17 If there is an easy way to only pass the props that I need then that's what I do, but sometimes it seems more readable to just pass everything. Decide what I should do about this.
-Right now you can put logically impossible values in to the range slider (ex: at least 10 and at most 1). This doesn't crash anything (just gives no matches), but should I make impossible or warn?
5/12/17 IMPORTANT. I'm removing parseInt from the search component. All values entering the component will be numbers, and I believe that the range input will only return numbers, so I should be fine. But be sure to double check and look into this if I'm having problems.
5/11/17 Note somewhere that defaults in paramstovalues must be manually adjusted when new weather info added. No clean way to automate this.  Findmatches also must be manually updated.
-Do I even need minmax any more?
-Can I automate the creation of weatheroptions in jsoncreate?
5/9/17: Finished going through componentWillMount in App
5/8/17 TODO

-inputMinMax's [2] value is the midway point between min and max. I'm currently using that as the range input default, but I should come up with a better default system and make that the new [2] value. Once I decide what to do I need to change inputMinMax and finddefaultmatches and then copy over results of those changes.
-Finish updating app to reflect new info and naming scheme. I STARTED TO DO THIS BUT I then realized I should create inputMinMax to make things easier. Now only default state in app fully updated.
-IMPORTANT: I need to change my comparison values to <= and >=. If I use just < > I could cause problems because reasonable options (like 0) could be excluded.


VALUES IN STATIONSOBJ:

"mTmxAv"
"mTmnAv"
"andSnGe1"
"andSnCGe1"
"andPrGe5Ti"
"andTmnLe32"
"andTmxGe60"
"andTmxGe80"


Le =  max allowable
Ge = min allowable



WEATHER INPUT values

hMTmxAvLe
lMTmnAvGe
andSnGe1Le
andSnGe1Ge
andSnCGe1Le
andSnCGe1Ge
andPrGe5TiLe
andPrGe5TiGe
andTmnLe32Le
andTmnLe32Ge
andTmxGe60Le
andTmxGe60Ge
andTmxGe80Le
andTmxGe80Ge
